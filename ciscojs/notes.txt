Js is a interpreted language.
node.js- interpreter
JS uses JIT compilation, websites-client-side programming.used for interactivity and to dynamically change the content. 
JS needs 3 things: 
-code editor, interpreter(bootable environment) and debugger.
-package managers- enabling management of libraries- containing ready-made solution that we can use in our programs or components of the development enviourment.
-tast runners and module bundlers- to automate the process and merge the resulting code from many files and libraries- Grunt or webpack
-tesing framework- allows testing- mocha, jasmin jest
-security analyzers- used to control the securit of our solution- snyk, retireJS, OWASP dependency check

Interpreter- functions as a runtime environment for programms,
if we want server-side- node.js. if we want-client side- the web browser we are using

debugger- tool allows you t oslow down or halt execution of program, run instructions steb by step  and analyze state of the program
-web browser- boot environment, JS interpreted and debugger(dev tools)
browser has: inspector- to analyze html element of open website, 
JS console- shows all info about errors, debugger

defer – means that the script should be executed after the whole page is loaded;
async – means that the script will be executed immediately, but in parallel to parsing the rest of the page.


var. let- variable that can be changed, 
const- constant- can not be changed. 

var height
let weight
console.log(height); // -> undefined
console.log(weight); // -> Uncaught ReferenceError: weight is not defined

Because we haven't put anything there yet, the result is undefined (the interpreter knows this variable, but it has no value yet – the value is undefined). 
In the next line, we try to print out the contents of the weight variable ... which we forgot to declare. This time, we will see ReferenceError. 
The JavaScript interpreter, which executes our program, has informed us that it doesn’t know a variable by this name (so the variable itself is undefined).

One of the basic differences in the use of var and let is that let prevents us from declaring another variable with the same name (an error is generated). 
Using var allows you to re-declare a variable, which can potentially lead to errors in the program execution.

Let- reserves the variable, while var allows for re-declaring and possible bugs

Initializing a variable- give the variable value. 
You can assign to a variable: a specific value; the contents of another variable; or, for example, the result returned by a function.
Data types vary greatly depending on the programming language. In JavaScript, the main types are number and character string.
Variables in the JavaScript language are untyped (or, to be more precise, they are weakly and dynamically typed).
 This means that JavaScript will not control what type of value we store in the variable. What exactly is the data type? 
 You can probably intuitively answer this question yourself. The type determines the belonging of a given data to a certain set 
 that share the same properties and on which you can perform the same operations.

We can separate the code of a program into blocks. In the blocks that we create using curly brackets, there is a set of instructions, which for some reason should be treated independently.
 If we declare any variable or constant using let or const, respectively, outside the code blocks, they will be global.
 What happens if we declare something using let or const inside a block? This will create a local variable or constant. 
 It will be visible only inside the block in which it was declared and in blocks that can optionally be nested in it.

 let height = 180;
  {
    let weight = 70;
    console.log(height); // -> 180
    console.log(weight); // -> 70
  }
console.log(height); // -> 180
console.log(weight); // -> Uncaught ReferenceError: weight is not defined

var
In the case of variable declarations using the keyword var, 
the situation is slightly different. The variable declared using it outside the blocks will, as in the case of let, be global, in other words, it will be visible everywhere. 
If you declare it inside a block, then... well, it will usually turn out to be global again.
The problem is that var ignores ordinary program blocks, treating them as if they do not exist. 
So in what situation can we declare a local variable using var? Only inside a function. We will devote a lot of space to discussing the function, 
and then we will come back to the problem of the variable scope as well. Now we will try to present and discuss only a simple example, 
which will show that var variables are sometimes local, too.

variable declarations using the word var can also be local. if also used in a function.

Variable shadoing- in JS we can declare a global variable and local variable of the same name.
In the local scope, in which we declare a local variable using its name, we will have access to the local value
(the global variable is hidden behind the local one, so we do not have access to it in this local scope).
This is not best programming practice, we should avoid such situations. 

Hoisting- action performed by the JS interpreter, searching for all variable declarations and moving them to the 
beginning of the range in which they were declared (
  -to the beginning of the program if they are global,
  -to the beginning of the block if its a local LET declaration, 
  -to the begining of the function if its a loal VAR declaration
)
All of this happens in the interpreter memory and changes are not visible in code.
Hoisting is complex and sometimes incoherent dechanism-> hence we need to be areful when using it. 

Data types and conversions
JS is a weakly typed language, so it allows to change the type of data stored in one variable.
Numbers can be devided into Integer numbers and real numbers.

In JS datatypes are divided int primitive(or simple) and complex(or composite).

Primitive types can be numbers and strings of characters.
Complex types can be arrays and objects.
(if you store data in a primitive type of variable- the data will be atomic(it will not be possible to extract components from it),
 HOWEVER if the data is stored in a complex type such as an array- will consist of many elements of primitive types which can be extracted)

Literals- its a way of noting specific values(data in the program code). In JS they are used to initialize variables.
in JS almost each data type has its own literal.

typeof operator:
the typeof operator is unary(it takes only one argument) and informs us of the type of data indicated as a given argument.
the argument can be a literal or a variable then it returns a string about the type of data stored in it. There are fixed values assigned to each of the types:
"undefined"
"object"
"boolean"
"number"
"bigint"
"string"
"symbol"
"function"

Primitive data types
in JS there are six primitive data types: 
Boolean,
Number,
BigInt,
String, 
Symbol, 
undefined.
Null value will be also treated as a separte type. The primitives have a type of data whose values are atomic.(meaning- the value is one indivisible element.)

Boolean- logical data type- takes 2 values- true or false. Mainly used as a conditional expression for deciding what part of the code should be executed,
OR how long something should be repeated(control flow statement).

Booleans are also used as a FLAG, variable that signals something that can be either present or absent. enabled or disabled. 
Common prefix for boolean names- 'is'  (ex- isDataValid, isStringTooLong)
We can perform, without conversion(change to another type) logical operation on boolean values, as known from mathematics.
such as NOT, AND and OR(the symbols !, && and || correspondingly).

Number- main numeric type that represents both real number(e.g. fractions) and integers.
The format in which the data of this type is stored in the memory means that the values of this type are sometimes approximate 
(especially, but not only, very large values or some fractions). It is assumed, among other things, that in order to ensure the correctness of calculations, 
the integer values should be limited in JavaScript to the range from -(253 – 1) to (253 – 1).

In addition to regular numbers in JavaScript, we use three additional special values, which are: Infinity, -Infinity and NaN (not a number)
 NaN, is not so much a numerical value as a notification that some arithmetic action (or mathematical function) 
 could not be performed because the argument is either not a number, or cannot be converted to a number.

BigInt- its not used too often- it allows us to write integers of virtually any lenght.
We can use mathematical operations on BigInts in the same way as on Numbers, but there is a difference when dividing.
 As the BigInt is an integer type, the division result will always be rounded down to the nearest whole number.

The BigInt does not have its own equivalent of Infinity or NaN values. In the case of the Number type, 
such values appear when dividing by 0 (Infinity result) or trying to perform an arithmetic action on a value that is not a number (NaN result). 
In the case of the BigInt type, such actions will generate an error.


String- represents sequence of characters forming a piece of text. Most common operatons for text include concatenation, extraction of substing or checking the length of the string.
Strings like other primitives are immutable, so when we want to change even one letter in a string, in reality we create a new string. 

Trying to perform arithmetic operations on String type values, such as subtraction, multiplication, or division, will usually end in an error. 
More precisely, the NaN value will be returned as a result of the action.
A very convenient mechanism that was introduced to JavaScript in 2015 is string interpolation. 
It allows you to treat a character string as a template, in which you can place values in selected places, such as those taken from variables. 
Such a literal is created using backticks (or grave accents) instead of quotation marks. The places where values are inserted are marked with curly brackets preceded by a $ sign.

let country = "Malawi";
let continent = "Africa";
   
let sentence = ` ${country} is located in ${continent}.`;
console.log(sentence); // -> Malawi is located in Africa.

A method is a special kind of function that belongs to an object. Objects are complex data types, which can consist of many values (stored in properties) and methods.

All data of primitive types such as Number, BigInt, Boolean, or String have corresponding objects to which they can be converted. 
Each of these objects will have methods designed for a specific data type. At this point, we come to another concept, that is, autoboxing. 
If a dot appears after a literal representing a primitive type, or after a variable containing this type of data, 
the JavaScript interpreter tries to treat this value as an object and not a primitive. 
For this purpose, it converts the primitive to the corresponding object on the fly, which has the appropriate methods (i.e. it performs autoboxing). 

let river = "Mekong";
let character = river.charAt(2);
console.log(character); // -> k

In the variable river, we store the primitive of a String type. In the next line, we refer to this variable, writing a dot after its name and the name of one of the methods – 
charAt (a method of the String class object). Although the primitive has no methods that can be called, 
the interpreter temporarily converts this value to a suitable object that already has such methods. One of these methods is charAt, which we now call. 
The method operates on a string originally placed in the river variable, and returns a single letter from the specified position (letters are counted starting from 0).
After the operation is completed, the interpreter removes the temporary object. 

Commonly used string methods and properties are: 
-length: property, returns the number of characters in a string;
-charAt(index): method, returns the character at the "index" position in the string (indexes start from 0);
-slice(beginIndex, [optional] endIndex): method, returns a new string that is created from the characters between beginIndex (included) and endIndex (excluded);
 if endIndex is omitted, then the new string is from beginIndex to the end of the string;
-split(separator, [optional] limit): method, splits the string into substrings whenever a separator is found in that string, 
and returns an array of those substrings (we will say a few words about arrays in a moment), while an optional limit limits the number of substrings added to the list.

let str = "java script language";
   
console.log(str.length); // -> 20
console.log('test'.length); // -> 4
   
console.log(str.charAt(0)); // -> 'j'
console.log('abc'.charAt(1)); // -> 'b'
   
console.log(str.slice(0, 4)); // -> 'java'
console.log('test'.slice(1, 3)); // -> 'es'
   
console.log(str.split(' ')); // -> ['java', 'script', 'language']
console.log('192.168.1.1'.split('.')); // -> ['192', '168', '1', '1']

Undefined- 
The undefined type has only one value: undefined. It’s the default value that all variables have after a declaration if no value is assigned to them. 
You can also assign the value undefined to any variable, but in general, this should be avoided, because if we need to mark a variable as not holding any meaningful value, we should use null.

Symbol 
It’s a new primitive type that was added to JavaScript in 2015. It doesn't have any literal value, and can only be created using a special constructor function. 
Symbols are a form of identifier that are guaranteed to be unique.

Null 
It is quite specific- the value itself is primitive, while the type of which it belngs- its not primitive-> Number or undefined. 
The null value is used to indicate that the variable does not contain anything, and most often it is a variable that is intended to contain values of complex types(such as objects).

In a nutshell, we can assume that the undefined value is assigned to uninitialized variables automatically, 
but if we want to explicitly indicate that the variable does not contain anything, we assign it a null value. One important caveat for null is that when checked with the typeof operator, 
it will return "object", a surprising result. This is a part of a much more complicated object system, but for now, you just need to know that typeof null is equal to "object".

Type conversions: 

Primitive construction functions
There are two tupes to create variables in JS- using literals and using constructor functions.
the following functions will return primitives of a given type:
boolean, Number, bigIng and String.-> they can be called without arguments.

the function String will by default create and return an empty string- primitive 
the function Number will by default create and return the value of 0
the function Boolean will by default create and return the value of false.
the function BigInt will need to have initial value, otherwise it will not be able to return a result

Conversions: 

Conversion to string: 
let str = "text";
let strStr = String(str);
console.log(`${typeof str} : ${str}`); // -> string : text
console.log(`${typeof strStr} : ${strStr}`); // -> string : text
   
let nr = 42;
let strNr = String(nr);
console.log(`${typeof nr} : ${nr}`); // -> number : 42
console.log(`${typeof strNr} : ${strNr}`); // -> string : 42
   
let bl = true;
let strBl = String(bl);
console.log(`${typeof bl} : ${bl}`); // -> boolean : true
console.log(`${typeof strBl} : ${strBl}`); // -> string : true


Conversion to number:
the string can also contain numbers in hexadecimal, octal, and binary format. They must be preceded by 0x, 0o, or 0b respectively.
For any string that cannot be converted to a special value, NaN (not a number) is returned. A BigInt can also be converted to a Number,
but we need to remember that a BigInt can store much bigger values than a Number, so for large values, part of them can be truncated or end up being imprecise.
The Boolean true is converted to 1, and false to 0 – this is common for many programming languages. An attempt to convert an undefined value will result in NaN, while null will be converted to 0.

console.log(Number(42)); // -> 42
   
console.log(Number("11")); // -> 11
console.log(Number("0x11")); // -> 17
console.log(Number("0o11")); // -> 9
console.log(Number("0b11")); // -> 3
console.log(Number("12e3")); // -> 12000
console.log(Number("Infinity"));// -> Infinity
console.log(Number("text")); // -> NaN

Conversion to Boolean: 
Conversions to Boolean follow simple rules, as we can only have one of two values: true or false. The value false is always returned for:

0,
NaN,
empty string,
undefined,
null
Any other value will result in true being returned.
console.log(Boolean(true)); // -> true
   
console.log(Boolean(42)); // -> true
console.log(Boolean(0)); // -> false
console.log(Boolean(NaN)); // -> false
   
console.log(Boolean("text")); // -> true
console.log(Boolean("")); // -> false


In order for conversions to a BigInt to succeed, we require a Number or String representing a number as a value to be converted. Values for conversion can be given in the default decimal form, as well as in hexadecimal, octal, or binary form. 
This applies both to the situation where we give the Number and String literals as arguments (or variables containing data of those types). We can also use exponential notation, but only for Number arguments. 
Unlike other conversions, conversion to a BigInt will throw an error, and will stop the program when unable to convert a given value.

console.log(BigInt(11)); // -> 11n
console.log(BigInt(0x11)); // -> 17n
console.log(BigInt(11e2)); // -> 1100n
   
console.log(BigInt(true)); // -> 1n
   
console.log(BigInt("11")); // -> 11n
console.log(BigInt("0x11")); // -> 17n
   
console.log(BigInt(null)); // -> Uncaught TypeError: Cannot convert null to a BigInt
   
console.log(BigInt(undefined)); // -> Uncaught TypeError: Cannot convert undefined to a BigInt
   
console.log(BigInt(NaN)); // -> Uncaught RangeError: The number NaN cannot be converted to a BigInt because it is not an integer


Implicit conversions: 
Conversions can also happen automatically, and they happen all the time. This simple example will demonstrate it (we tested a similar example when discussing the String type):

const str1 = 42 + "1";
console.log(str1); // -> 421
console.log(typeof str1); // -> string
   
const str2 = 42 - "1";
console.log(str2); // -> 41
console.log(typeof str2); // -> number

JavaScript will convert the rest of the arguments to a string as well. This is what is happening with str1 in the example. Subtraction with a string, however, doesn't make much sense, so in that case JavaScript converts everything to Numbers.

/////////////////////////////////////////////////////////////


Complex data types.[objects and arrays]

Objects- have many applications in JS. One of them is record- record is a collection of named fields. Each filed has its own name (or key) and value assigned to it.
in the case of JS objects - these fields are called properties. Records( or in our ase objects allow you to store multiple values of different types in once place.)
easies way to create an object is to use curly bracket.
let testObj = {};
this is an empty object- it does not have any key-value pairs, we can define them below:

let testObj = {
  nr: 600, // nr(key): 600(value) => key-value pair
  str:"text"
};
Key-value pairs are separated by commas. The specific property can be reffered with dot notation: 

console.log(testObj.nr);// >600

Why Objects are useful? We can store several values in one place, which are liked to each other for some reason. 

let user1 = {
    name: "Calvin",
    surname: "Hart",
    age: 66,
    email: "CalvinMHart@teleworm.us"
};

let user2 = {
    name: "Mateus",
    surname: "Pinto",
    age: 21,
    email: "MateusPinto@dayrep.com"
};

We can both read and modify the value associated with a particular key. What is more, we can also modify the whole object by adding a new, previously non-existent property.
 We also do this using dot notation – if during an attempt to modify the property the interpreter does not find the key we specify, it will create it.


console.log(user1.name); // -> Calvin
console.log(user2.name); // -> Mateus
   
console.log(user1.age); // -> 66
user1.age = 67;
console.log(user1.age); // -> 67
   
console.log(user2.phone); // -> undefined
user2.phone = "904-399-7557";
console.log(user2.phone); // -> 904-399-7557

You can also delete the newly added information: 

console.log(user2.phone); // -> 904-399-7557
delete user2.phone;
console.log(user2.phone); // -> undefined


////////////////////////////////////////////////////////

Array: 
An array is like and object- complex data type that can be used to store a data collection- the stored
data type can be of any type-(similar to object) The difference between these structures is that in array we only store values,
without the associated names (i.e the keys).

The values inside an array are index based. JS arrays start from 0.
Easiest way to create arrays in JS is to use square brackets-array literal- used for creating empty arrays and arrays containing initial elements.
reffering to a partiular element-> by using bracket notation

let days = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
console.log(days[0]); // -> Sun
console.log(days[2]); // -> Tue
console.log(days[5]); // -> Fri
   
days[0] = "Sunday";
console.log(days[0]); // -> Sunday
   
let emptyArray = [];
console.log(emptyArray[0]); // -> undefined

How can we add a new element to an existing array, for example, an empty one?

The easiest way would be to assign a new value to a specific position using bracket notation.
 For the interpreter, it doesn't matter if there is already something in this index or not. 
 It just places a new value in there. What's interesting is that we don't have to fill the array with elements one by one – you can leave empty spaces in it.

 let animals = [];
console.log(animals[0]); // -> undefined
   
animals[0] = "dog";
animals[2] = "cat";
   
console.log(animals[0]); // -> dog
console.log(animals[1]); // -> undefined
console.log(animals[2]); // -> cat

we store the same type of data in one array, but as we mentioned earlier, this is not required by JavaScript. So we can easily create an array containing elements of different types.


let values = ["Test", 7, 12.3, false];


What is interesting is the fact that we can also store arrays as elements of the array, and we can access the elements of this nested array using multiple square brackets.

let names = [["Olivia", "Emma", "Mia", "Sofia"], ["William", "James", "Daniel"]];
console.log(names[0]); // -> ["Olivia", "Emma", "Mia", "Sofia"]
console.log(names[0][1]); // -> Emma
console.log(names[1][1]); // -> James
   
let femaleNames = names[0];
console.log(femaleNames[0]); // -> Olivia
console.log(femaleNames[2]); // -> Mia

we can add new elements to an array while the program is running.

in JavaScript, everything except primitives is an object. Arrays are also treated as a special kind of object. 
The typeof operator does not distinguish between object types (or more precisely, classes), so it informs us that the days variable contains an object. 
If we would like to make sure that the variable contains an array, we can do it using the instanceof operator, among others.

let days = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
let day = "Sunday";
   
console.log(typeof days); // -> object
console.log(typeof day); // -> string
   
console.log(days instanceof Array); // -> true
console.log(day instanceof Array); // -> false


///////////////////////////////
Array methods:

Length
The length property is used to get information about the length (the number of elements) of the array (including empty positions between existing elements).

let names = ["Olivia", "Emma", "Mateo", "Samuel"];
console.log(names.length); // -> 4

IndexOf
The indexOf method is used to search the array to locate a given value. If the value is found (the element is in the array), its index (position) will be returned. 
The method returns -1 if the element is not found. If there is more than one element with the same value in the array, the index of the first element is returned.

let names = ["Olivia", "Emma", "Mateo", "Samuel"];
console.log(names.indexOf("Mateo")); // -> 2
console.log(names.indexOf("Victor")); // -> -1


Push
The push method places the element given as its argument at the end of the array. The length of the array is increased by 1, and the new element is inserted on the right (it has the largest index of all elements).
et names = ["Olivia", "Emma", "Mateo", "Samuel"];
console.log(names.length); // -> 4
   
names.push("Amelia");
console.log(names.length); // -> 5
console.log(names); // - > ["Olivia", "Emma", "Mateo",
"Samuel", "Amelia"]


Unshift
The unshift method works similarly to push, the difference being that a new element is added to the beginning of the array. The array length is increased by 1, all the old elements are moved to the right and the new element is placed in the empty space that has been created at the beginning of the array. The index of the new element is 0.

let names = ["Olivia", "Emma", "Mateo", "Samuel"];
console.log(names.indexOf("Mateo")); // -> 2
console.log(names.indexOf("Victor")); // -> -1


Pop
The pop method allows you to remove the last element from the array. As a result of its execution, the element with the largest index is returned, while at the same time it is removed from the original array. The length of the array is obviously reduced by 1.

let names= ["Olivia", "Emma", "Mateo", "Samuel"];
console.log(names.length); // -> 4
   
let name = names.pop();
console.log(names.length); // -> 3
console.log(name); // -> Samuel
console.log(names); // -> ["Olivia", "Emma", "Mateo"]


Shift
The shift method works similarly to pop, only this time we remove the element from the beginning of the array (with the index 0). 
The removed element is returned by the method, all other elements are shifted to the left, completing the empty space. The length of the original array is reduced by 1.


let names = ["Olivia", "Emma", "Mateo", "Samuel"];
console.log(names.length); // -> 4
   
let name = names.shift();
console.log(names.length); // -> 3
console.log(name); // -> Olivia
console.log(names); // -> ["Emma", "Mateo", "Samuel"]

Reverse
The reverse method reverses the order of elements in the array. As a result of its calling, the first element of the original array will become the last, the second last but one, and so on.

let names = ["Olivia", "Emma", "Mateo", "Samuel"];
   
names.reverse();
console.log(names); // -> ["Samuel", "Mateo", "Emma",
   "Olivia"]
  

Slice
The slice method allows you to create a new array from selected elements of the original array. 
Calling the method does not affect the original array. The method takes either one or two integer values as arguments.

The basic combinations are:

one argument larger than zero – all elements from the index given as an argument to the end of the array are copied;
two arguments larger than zero – the element from the index specified as the first argument to the element specified as the second argument are copied;
two arguments, first positive, second negative – all elements from the specified index to the end of the array are copied, except for the specified number of the last elements (e.g. argument -3 means that we do not copy the last three elements)
one negative argument – the specified number of the last elements are copied to the end of the array (e.g. -2 means that you copy the last two elements).

let names = ["Olivia", "Emma", "Mateo", "Samuel"];
   
let n1 = names.slice(2);
console.log(n1); // -> ["Mateo", "Samuel"]
   
let n2 = names.slice(1,3);
console.log(n2); // -> ["Emma", "Mateo"]
   
let n3 = names.slice(0, -1);
console.log(n3); // -> ["Olivia", "Emma", "Mateo"]
   
let n4 = names.slice(-1);
console.log(n4); // -> ["Samuel"]
   
console.log(names); // -> ["Olivia", "Emma", "Mateo",
   "Samuel"]


Concat
The concat method creates a new array by attaching elements from the array given as an argument to the original array elements. The method changes neither the original array nor the array specified as an argument.

let names = ["Olivia", "Emma", "Mateo", "Samuel"];
let otherNames = ["William", "Jane"];
let allNames = names.concat( otherNames);
   
console.log(names); // -> ["Olivia", "Emma", "Mateo",
   "Samuel"]
console.log(otherNames); // -> ["William", "Jane"]
console.log(allNames); // -> ["Olivia", "Emma", "Mateo",
   "Samuel", "William", "Jane"]

   
