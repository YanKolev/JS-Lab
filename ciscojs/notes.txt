Js is a interpreted language.
node.js- interpreter
JS uses JIT compilation, websites-client-side programming.used for interactivity and to dynamically change the content. 
JS needs 3 things: 
-code editor, interpreter(bootable environment) and debugger.
-package managers- enabling management of libraries- containing ready-made solution that we can use in our programs or components of the development enviourment.
-tast runners and module bundlers- to automate the process and merge the resulting code from many files and libraries- Grunt or webpack
-tesing framework- allows testing- mocha, jasmin jest
-security analyzers- used to control the securit of our solution- snyk, retireJS, OWASP dependency check

Interpreter- functions as a runtime environment for programms,
if we want server-side- node.js. if we want-client side- the web browser we are using

debugger- tool allows you t oslow down or halt execution of program, run instructions steb by step  and analyze state of the program
-web browser- boot environment, JS interpreted and debugger(dev tools)
browser has: inspector- to analyze html element of open website, 
JS console- shows all info about errors, debugger

defer – means that the script should be executed after the whole page is loaded;
async – means that the script will be executed immediately, but in parallel to parsing the rest of the page.


var. let- variable that can be changed, 
const- constant- can not be changed. 

var height
let weight
console.log(height); // -> undefined
console.log(weight); // -> Uncaught ReferenceError: weight is not defined

Because we haven't put anything there yet, the result is undefined (the interpreter knows this variable, but it has no value yet – the value is undefined). 
In the next line, we try to print out the contents of the weight variable ... which we forgot to declare. This time, we will see ReferenceError. 
The JavaScript interpreter, which executes our program, has informed us that it doesn’t know a variable by this name (so the variable itself is undefined).

One of the basic differences in the use of var and let is that let prevents us from declaring another variable with the same name (an error is generated). 
Using var allows you to re-declare a variable, which can potentially lead to errors in the program execution.

Let- reserves the variable, while var allows for re-declaring and possible bugs

Initializing a variable- give the variable value. 
You can assign to a variable: a specific value; the contents of another variable; or, for example, the result returned by a function.
Data types vary greatly depending on the programming language. In JavaScript, the main types are number and character string.
Variables in the JavaScript language are untyped (or, to be more precise, they are weakly and dynamically typed).
 This means that JavaScript will not control what type of value we store in the variable. What exactly is the data type? 
 You can probably intuitively answer this question yourself. The type determines the belonging of a given data to a certain set 
 that share the same properties and on which you can perform the same operations.

We can separate the code of a program into blocks. In the blocks that we create using curly brackets, there is a set of instructions, which for some reason should be treated independently.
 If we declare any variable or constant using let or const, respectively, outside the code blocks, they will be global.
 What happens if we declare something using let or const inside a block? This will create a local variable or constant. It will be visible only inside the block in which it was declared and in blocks that can optionally be nested in it.

 let height = 180;
  {
    let weight = 70;
    console.log(height); // -> 180
    console.log(weight); // -> 70
  }
console.log(height); // -> 180
console.log(weight); // -> Uncaught ReferenceError: weight is not defined

var
In the case of variable declarations using the keyword var, 
the situation is slightly different. The variable declared using it outside the blocks will, as in the case of let, be global, in other words, it will be visible everywhere. If you declare it inside a block, then... well, it will usually turn out to be global again.
The problem is that var ignores ordinary program blocks, treating them as if they do not exist. So in what situation can we declare a local variable using var? Only inside a function. We will devote a lot of space to discussing the function, 
and then we will come back to the problem of the variable scope as well. Now we will try to present and discuss only a simple example, which will show that var variables are sometimes local, too.

variable declarations using the word var can also be local. if also used in a function.

Variable shadoing- in JS we can declare a global variable and local variable of the same name.
In the local scope, in which we declare a local variable using its name, we will have access to the local value
(the global variable is hidden behind the local one, so we do not have access to it in this local scope).
This is not best programming practice, we should avoid such situations. 

Hoisting- action performed by the JS interpreter, searching for all variable declarations and moving them to the 
beginning of the range in which they were declared (
  -to the beginning of the program if they are global,
  -to the beginning of the block if its a local LET declaration, 
  -to the begining of the function if its a loal VAR declaration
)
All of this happens in the interpreter memory and changes are not visible in code.
Hoisting is complex and sometimes incoherent dechanism-> hence we need to be areful when using it. 

Data types and conversions
JS is a weakly typed language, so it allows to change the type of data stored in one variable.
Numbers can be devided into Integer numbers and real numbers.

In JS datatypes are divided int primitive(or simple) and complex(or composite).

Primitive types can be numbers and strings of characters.
Complex types can be arrays and objects.
(if you store data in a primitive type of variable- the data will be atomic(it will not be possible to extract components from it),
 HOWEVER if the data is stored in a complex type such as an array- will consist of many elements of primitive types which can be extracted)

Literals- its a way of noting specific values(data in the program code). In JS they are used to initialize variables.
in JS almost each data type has its own literal.

typeof operator:
the typeof operator is unary(it takes only one argument) and informs us of the type of data indicated as a given argument.
the argument can be a literal or a variable then it returns a string about the type of data stored in it. There are fixed values assigned to each of the types:
"undefined"
"object"
"boolean"
"number"
"bigint"
"string"
"symbol"
"function"

Primitive data types
in JS there are six primitive data types: 
Boolean,
Number,
BigInt,
String, 
Symbol, 
undefined.
Null value will be also treated as a separte type. The primitives have a type of data whose values are atomic.(meaning- the value is one indivisible element.)

Boolean- logical data type- takes 2 values- true or false. Mainly used as a conditional expression for deciding what part of the code should be executed,
OR how long something should be repeated(control flow statement).

Booleans are also used as a FLAG, variable that signals something that can be either present or absent. enabled or disabled. 
Common prefix for boolean names- 'is'  (ex- isDataValid, isStringTooLong)
We can perform, without conversion(change to another type) logical operation on boolean values, as known from mathematics.
such as NOT, AND and OR(the symbols !, && and || correspondingly).

Number- main numeric type that represents both real number(e.g. fractions) and integers.
The format in which the data of this type is stored in the memory means that the values of this type are sometimes approximate 
(especially, but not only, very large values or some fractions). It is assumed, among other things, that in order to ensure the correctness of calculations, 
the integer values should be limited in JavaScript to the range from -(253 – 1) to (253 – 1).

In addition to regular numbers in JavaScript, we use three additional special values, which are: Infinity, -Infinity and NaN (not a number)
 NaN, is not so much a numerical value as a notification that some arithmetic action (or mathematical function) could not be performed because the argument is either not a number, or cannot be converted to a number.

BigInt- its not used too often- it allows us to write integers of virtually any lenght.
We can use mathematical operations on BigInts in the same way as on Numbers, but there is a difference when dividing. As the BigInt is an integer type, the division result will always be rounded down to the nearest whole number.

The BigInt does not have its own equivalent of Infinity or NaN values. In the case of the Number type, such values appear when dividing by 0 (Infinity result) or trying to perform an arithmetic action on a value that is not a number (NaN result). In the case of the BigInt type, such actions will generate an error.


String- represents sequence of characters forming a piece of text. Most common operatons for text include concatenation, extraction of substing or checking the length of the string.
Strings like other primitives are immutable, so when we want to change even one letter in a string, in reality we create a new string. 

Trying to perform arithmetic operations on String type values, such as subtraction, multiplication, or division, will usually end in an error. More precisely, the NaN value will be returned as a result of the action.
A very convenient mechanism that was introduced to JavaScript in 2015 is string interpolation. It allows you to treat a character string as a template, in which you can place values in selected places, such as those taken from variables. Such a literal is created using backticks (or grave accents) instead of quotation marks. The places where values are inserted are marked with curly brackets preceded by a $ sign.

let country = "Malawi";
let continent = "Africa";
   
let sentence = ` ${country} is located in ${continent}.`;
console.log(sentence); // -> Malawi is located in Africa.

A method is a special kind of function that belongs to an object. Objects are complex data types, which can consist of many values (stored in properties) and methods.

All data of primitive types such as Number, BigInt, Boolean, or String have corresponding objects to which they can be converted. Each of these objects will have methods designed for a specific data type. At this point, we come to another concept, that is, autoboxing. If a dot appears after a literal representing a primitive type, or after a variable containing this type of data, the JavaScript interpreter tries to treat this value as an object and not a primitive. For this purpose, it converts the primitive to the corresponding object on the fly, which has the appropriate methods (i.e. it performs autoboxing). 
let river = "Mekong";
let character = river.charAt(2);
console.log(character); // -> k

In the variable river, we store the primitive of a String type. In the next line, we refer to this variable, writing a dot after its name and the name of one of the methods – charAt (a method of the String class object). Although the primitive has no methods that can be called, the interpreter temporarily converts this value to a suitable object that already has such methods. One of these methods is charAt, which we now call. The method operates on a string originally placed in the river variable, and returns a single letter from the specified position (letters are counted starting from 0).
After the operation is completed, the interpreter removes the temporary object. 

Commonly used string methods and properties are: 
-length: property, returns the number of characters in a string;
-charAt(index): method, returns the character at the "index" position in the string (indexes start from 0);
-slice(beginIndex, [optional] endIndex): method, returns a new string that is created from the characters between beginIndex (included) and endIndex (excluded); if endIndex is omitted, then the new string is from beginIndex to the end of the string;
-split(separator, [optional] limit): method, splits the string into substrings whenever a separator is found in that string, and returns an array of those substrings (we will say a few words about arrays in a moment), while an optional limit limits the number of substrings added to the list.

let str = "java script language";
   
console.log(str.length); // -> 20
console.log('test'.length); // -> 4
   
console.log(str.charAt(0)); // -> 'j'
console.log('abc'.charAt(1)); // -> 'b'
   
console.log(str.slice(0, 4)); // -> 'java'
console.log('test'.slice(1, 3)); // -> 'es'
   
console.log(str.split(' ')); // -> ['java', 'script', 'language']
console.log('192.168.1.1'.split('.')); // -> ['192', '168', '1', '1']

Undefined- 
The undefined type has only one value: undefined. It’s the default value that all variables have after a declaration if no value is assigned to them. You can also assign the value undefined to any variable, but in general, this should be avoided, because if we need to mark a variable as not holding any meaningful value, we should use null.

Symbol 
It’s a new primitive type that was added to JavaScript in 2015. It doesn't have any literal value, and can only be created using a special constructor function. Symbols are a form of identifier that are guaranteed to be unique.

Null 
It is quite specific- the value itself is primitive, while the type of which it belngs- its not primitive-> Number or undefined. 
The null value is used to indicate that the variable does not contain anything, and most often it is a variable that is intended to contain values of complex types(such as objects).

In a nutshell, we can assume that the undefined value is assigned to uninitialized variables automatically, but if we want to explicitly indicate that the variable does not contain anything, we assign it a null value. One important caveat for null is that when checked with the typeof operator, it will return "object", a surprising result. This is a part of a much more complicated object system, but for now, you just need to know that typeof null is equal to "object".
